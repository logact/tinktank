# 参考
[RabbitMQ面试题（总结最全面的面试题） - 掘金 (juejin.cn)](https://juejin.cn/post/6844904125935665160#heading-12)
# 架构
-   Broker： 简单来说就是消息队列服务器实体
-   Exchange： 消息交换机，它指定消息按什么规则，路由到哪个队列
-   Queue： 消息队列载体，每个消息都会被投入到一个或多个队列
-   Binding： 绑定，它的作用就是把exchange和queue按照路由规则绑定起来
-   Routing Key： 路由关键字，exchange根据这个关键字进行消息投递
-   VHost： vhost 可以理解为虚拟 broker ，即 mini-RabbitMQ server。其内部均含有独立的 queue、exchange 和 binding 等，但最最重要的是，其拥有独立的权限系统，可以做到 vhost 范围的用户控制。当然，从 RabbitMQ 的全局角度，vhost 可以作为不同权限隔离的手段（一个典型的例子就是不同的应用可以跑在不同的 vhost 中）。
-   Producer： 消息生产者，就是投递消息的程序
-   Consumer： 消息消费者，就是接受消息的程序
-   Channel： 消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务

由Exchange、Queue、RoutingKey三个才能决定一个从Exchange到Queue的唯一的线路。
## 工作模式
**一.simple模式（即最简单的收发模式）**

![[Pasted image 20221009172413.png]]
1.  消息产生着§将消息放入队列
2.  消息的消费者(consumer) 监听(while) 消息队列,如果队列中有消息,就消费掉,消息被拿走后,自动从队列中删除(隐患 消息可能没有被消费者正确处理,已经从队列中消失了,造成消息的丢失)应用场景:聊天(中间有一个过度的服务器;p端,c端)

**二.work工作模式(资源的竞争)**
![[Pasted image 20221009172727.png]]


1.  消息产生者将消息放入队列消费者可以有多个,消费者1,消费者2,同时监听同一个队列,消息被消费?C1 C2共同争抢当前的消息队列内容,谁先拿到谁负责消费消息(隐患,高并发情况下,默认会产生某一个消息被多个消费者共同使用,可以设置一个开关(syncronize,与同步锁的性能不一样) 保证一条消息只能被一个消费者使用)
2.  应用场景:红包;大项目中的资源调度(任务分配系统不需知道哪一个任务执行系统在空闲,直接将任务扔到消息队列中,空闲的系统自动争抢)

**三.publish/subscribe发布订阅(共享资源)**
![[Pasted image 20221009172600.png]]



1.  X代表交换机rabbitMQ内部组件,erlang 消息产生者是代码完成,代码的执行效率不高,消息产生者将消息放入交换机,交换机发布订阅把消息发送到所有消息队列中,对应消息队列的消费者拿到消息进行消费
2.  相关场景:邮件群发,群聊天,广播(广告)

**四.routing路由模式**

![[Pasted image 20221009172907.png]]

1.  消息生产者将消息发送给交换机按照路由判断,路由是字符串(info) 当前产生的消息携带路由字符(对象的方法),交换机根据路由的key,只能匹配上路由key对应的消息队列,对应的消费者才能消费消息;
2.  根据业务功能定义路由字符串
3.  从系统的代码逻辑中获取对应的功能字符串,将消息任务扔到对应的队列中业务场景:error 通知;EXCEPTION;错误通知的功能;传统意义的错误通知;客户通知;利用key路由,可以将程序中的错误封装成消息传入到消息队列中,开发者可以自定义消费者,实时接收错误;

**五.topic 主题模式(路由模式的一种)**

![[Pasted image 20221009172914.png]]

1.  星号井号代表通配符
2.  星号代表多个单词,井号代表一个单词
3.  路由功能添加模糊匹配
4.  消息产生者产生消息,把消息交给交换机
5.  交换机根据key的规则模糊匹配到对应的队列,由队列的监听消费者接收消息消费
## exchange 的类型
1. DirectExchange
2. FanoutExchange
3. TopicExchange
4. HeadersExchange

# 最佳实践
# 高级

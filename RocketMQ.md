# 参考
[面渣逆袭（RocketMQ面试题八股文）必看👍 | Java 程序员进阶之路 (tobebetterjavaer.com)](https://tobebetterjavaer.com/sidebar/sanfene/rocketmq.html#_2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%80%89%E6%8B%A9rocketmq)
[消费者分组（ConsumerGroup） | RocketMQ (apache.org)](https://rocketmq.apache.org/zh/)
# RocketMQ消息模型
rocketMQ采用发布订阅模型
	![[Pasted image 20221009134017.png]]
-   **Message**

**Message**（消息）就是要传输的信息。

一条消息必须有一个主题（Topic），主题可以看做是你的信件要邮寄的地址。

一条消息也可以拥有一个可选的标签（Tag）和额处的键值对，它们可以用于设置一个业务 Key 并在 Broker 上查找此消息以便在开发期间查找问题。

-   **Topic**

**Topic**（主题）可以看做消息的归类，它是消息的第一级类型。比如一个电商系统可以分为：交易消息、物流消息等，一条消息必须有一个 Topic 。

**Topic** 与生产者和消费者的关系非常松散，一个 Topic 可以有0个、1个、多个生产者向其发送消息，一个生产者也可以同时向不同的 Topic 发送消息。

一个 Topic 也可以被 0个、1个、多个消费者订阅。

-   **Tag**

**Tag**（标签）可以看作子主题，它是消息的第二级类型，用于为用户提供额外的灵活性。使用标签，同一业务模块不同目的的消息就可以用相同 Topic 而不同的 **Tag** 来标识。比如交易消息又可以分为：交易创建消息、交易完成消息等，一条消息可以没有 **Tag** 。

标签有助于保持你的代码干净和连贯，并且还可以为 **RocketMQ** 提供的查询系统提供帮助。

-   **Group**

RocketMQ中，订阅者的概念是通过消费组（Consumer Group）来体现的。每个消费组都消费主题中一份完整的消息，不同消费组之间消费进度彼此不受影响，也就是说，一条消息被Consumer Group1消费过，也会再给Consumer Group2消费。

消费组中包含多个消费者，同一个组内的消费者是竞争消费的关系，每个消费者负责消费组内的一部分消息。默认情况，如果一条消息被消费者Consumer1消费了，那同组的其他消费者就不会再收到这条消息。

-   **Message Queue**

**Message Queue**（消息队列），一个 Topic 下可以设置多个消息队列，Topic 包括多个 Message Queue ，如果一个 Consumer 需要获取 Topic下所有的消息，就要遍历所有的 Message Queue。

RocketMQ还有一些其它的Queue——例如ConsumerQueue。

-   **Offset**

在Topic的消费过程中，由于消息需要被不同的组进行多次消费，所以消费完的消息并不会立即被删除，这就需要RocketMQ为每个消费组在每个队列上维护一个消费位置（Consumer Offset），这个位置之前的消息都被消费过，之后的消息都没有被消费过，每成功消费一条消息，消费位置就加一。

# 消息的消费模型
消费模型有两种：
- 集群消费

一个消费者组共同消费一个主题的多个队列，一个队列只会被一个消费者消费
- 广播消费


而广播消费会发给消费者组中的每个消费者进行消费

类似于rabbitMQ中的fanout模型

# RocketMQ架构

![[Pasted image 20221009144331.png]]
# 高级进阶
## 延时消息
电商的订单超时自动取消，就是一个典型的利用延时消息的例子，用户提交了一个订单，就可以发送一个延时消息，1h后去检查这个订单的状态，如果还是未付款就取消订单释放库存。

RocketMQ是如何实现延时消息的？

简单，八个字：`临时存储`+`定时任务`。
Broker收到延时消息了，会先发送到主题（SCHEDULE_TOPIC_XXXX）的相应时间段的Message Queue中，然后通过一个定时任务轮询这些队列，到期后，把消息投递到目标Topic的队列中，然后消费者就可以正常消费这些消息。
![[Pasted image 20221009151652.png]]


## 如何分布式消息事务？半消息？
半消息：是指暂时还不能被 Consumer 消费的消息，Producer 成功发送到 Broker 端的消息，但是此消息被标记为 “暂不可投递” 状态，只有等 Producer 端执行完本地事务后经过二次确认了之后，Consumer 才能消费此条消息。

## 死信队列
死信队列用于处理无法被正常消费的消息，即死信消息。

当一条消息初次消费失败，**消息队列 RocketMQ 会自动进行消息重试**；达到最大重试次数(默认16)后，若消费依然失败，则表明消费者在正常情况下无法正确地消费该消息，此时，消息队列 RocketMQ 不会立刻将消息丢弃，而是将其发送到该**消费者对应的特殊队列中**，该特殊队列称为**死信队列**

**死信消息的特点**：

-   不会再被消费者正常消费。
-   有效期与正常消息相同，均为 3 天，3 天后会被自动删除。因此，需要在死信消息产生后的 3 天内及时处理。
- 一个死信队列对应一个 Group ID， 而不是对应单个消费者实例。  
如果一个 Group ID 未产生死信消息，[消息队列](https://so.csdn.net/so/search?q=%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97&spm=1001.2101.3001.7020) RocketMQ 不会为其创建相应的死信队列。  
一个死信队列包含了对应 Group ID 产生的所有死信消息，不论该消息属于哪个 Topic

**如何处理死信队列**

一条消息进入死信队列，意味着某些因素导致消费者无法正常消费该消息，因此，通常需要您对其  
进行特殊处理。排查可疑因素并解决问题后，可以在消息队列 RocketMQ 控制台重新发送该消息，让 消费者重新消费一次。

# RocketMQ高可用
如何保证rocketMQ是高可用的？

# relative
[[RabbitMQ]]



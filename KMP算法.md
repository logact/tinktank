## KMP 算法基础
KMP算法利用记录模式串每个字符后缀对应最长的公共前缀的位置来使得模式串在每次适配的时候得到下一次比较的位置
### 算法步骤
#### 核心流程
1. 计算模式串各个前缀的部分值得到部分值表
- 串部分值的计算方法
	 1. 得到串的所有的前缀集合
	 2. 得到串的所有的后缀集合
	 3. 得到1，2集合的交集
	 4. 交集中的最长串的长度
3. 主串与模式串逐个字符串匹配
	1. 如果遇到不匹配的字符主串位置i，模式串位置j
	2. 模式字符串的位置j向后移动的距离就是 `已匹配的字符串的长度L` 减去 `部分值表中j对应的值`
简化这个过程如果直接计算next数组
那么next[j]=PM[j-1]+1 ，next[1] =0
#### 代码实现
上述的步骤可以在手动计算的时候很方便的算出next数组，但是对于对于程序运算PM非常麻烦所以在代码实现该算法的时候，整个算法流程进行如下改造
1. next[1] = 0 对于第一个字符串就不匹配的直接主串前进一位，模式串到首个字符串
2. next[j] = max{k|p[1]...p[k-1]=p[j-k+1]...p[j-1]} 对于其余的请况直接next[j]的值应当是以已匹配的串最后一个字符结尾的模式串的子串的最长公共前缀串的下一个位置，为什么是最长的因为越长的话代表模式串移动的位置越少匹配到最多的可能不会漏掉
##### 推到j!=1时next[j]的过程
整体思想使用一个递推法
设next[j]=k next[j+1]=？
如果p[j]=p[k]那么对于上面的情况2我们可以得到p[j+1]=k+1
如果p[j]!=p[k]那么对于p[1]...p[k]=p[j-k+1]...p[j] 不成立，那么这就成立找出以等式左边为主串，等式右边为模式串找出最长的模式串。下一次尝试的位置应该是p[j]是否等于p[next[k]] (这里一直有点不太明白)

### 改进步骤
对于next数组计算的时候当p[next[j]]=p[j]就会重复比较，因为对于前面一次的s[i]就有p[j]换上p[next[j]]还是相同的字符串必然不会相同所以在计算next数组的时候不能出现这种请况，当在计算next数组的时候如果p[next[j]]=p[j]应当让next[j]修正为next[next[j]]
## KMP 算法基础
#### 特征
1. 主串绝不后退
2. 如果模式串中重复比较多会降低搜索效率
### 算法步骤
#### 手动计算
1. 计算模式串各个前缀的部分值得到部分值表
 - 串部分值的计算方法
	 1. 得到串的所有的前缀集合
	 2. 得到串的所有的后缀集合
	 3. 得到1，2集合的交集
	 4. 交集中的最长串的长度
2. 主串与模式串逐个字符串匹配
	1. 如果遇到不匹配的字符主串位置i，模式串位置j
	2. 模式字符串的位置j向后移动的距离就是 `已匹配的字符串的长度L` 减去 `部分值表中j对应的值`
#### 程序计算
1. 如果j=1,则f(j)=0,对于第一个字符串都不匹配主串的位置移动到下一个位置重新比较
2. 如果 j!=1,则为以j-1结尾（前一个字符匹配）的公共后缀（与模式串的前缀相同）的位置
	1. 设next[j] = k
	2. 如果p[j]=p[k]则由条件2得出next[j+1]=next[j]+1
	3. 如果p[j]!=p[k]那么应该寻找更小的以j结尾的后缀的公共前后缀
		1. 这就又变成了一个模式匹配问题，后缀串为主串，前缀串为模式串，这就很有意思了又重复这个模式匹配过程了，这样就可以通过前面计算的next数组值得到后面next数组的值

#### next数组的计算
next数组为直接计算得到的在模式串j出匹配不到时下一次模式串匹配的位置，在人工计算时使用前面所述的算法步骤-手动计算
### KMP算法思想
kmp算法利用记住模式串中的最大前缀后缀重合位置，来减少重复的计算，这里有两个关键的点
1. 主串中前面匹配过的子字符串中的后缀字符串必定是与模式串中的前缀字符串比较（因为主串不会后退） 
2. 一定是最大的前缀后缀的位置（也就是`部分值`）如果不是最长的前缀后缀就会造成模式串向后移动过多造成漏点
### 改进步骤

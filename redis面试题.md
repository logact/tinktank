# 参考
[面渣逆袭（Redis面试题八股文）必看👍 | Java 程序员进阶之路 (tobebetterjavaer.com)](https://tobebetterjavaer.com/sidebar/sanfene/redis.html)
# 问题
## 基础
### 1.说说什么是Redis?

![Redis图标](http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-96e079f9-49a3-4c55-b0a4-47d043732b62.png)

Redis是一种基于键值对（key-value）的NoSQL数据库。

比一般键值对数据库强大的地方，Redis中的value支持string（字符串）、hash（哈希）、 list（列表）、set（集合）、zset（有序集合）、Bitmaps（位图）、 HyperLogLog、GEO（地理信息定位）等多种数据结构，因此 Redis可以满足很多的应用场景。

而且因为Redis会将所有数据都存放在内存中，所以它的读写性能非常出色。

不仅如此，Redis还可以将内存的数据利用快照和日志的形式保存到硬盘上，这样在发生类似断电或者机器故障的时候，内存中的数据不会“丢失”。

除了上述功能以外，Redis还提供了键过期、发布订阅、事务、流水线、Lua脚本等附加功能。

总之，Redis是一款强大的性能利器。

### 2.Redis可以用来干什么？
![[Pasted image 20221010171348.png]]
1.  缓存
    
    这是Redis应用最广泛地方，基本所有的Web应用都会使用Redis作为缓存，来降低数据源压力，提高响应速度。 ![Redis缓存](http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-d44c2397-5994-452f-8b7b-eb85d2b87685.png)
    
2.  计数器 Redis天然支持计数功能，而且计数性能非常好，可以用来记录浏览量、点赞量等等。
    
3.  排行榜 Redis提供了列表和有序集合数据结构，合理地使用这些数据结构可以很方便地构建各种排行榜系统。
    
4.  社交网络 赞/踩、粉丝、共同好友/喜好、推送、下拉刷新。
    
5.  消息队列 Redis提供了发布订阅功能和阻塞队列的功能，可以满足一般消息队列功能。
    
6.  分布式锁 分布式环境下，利用Redis实现分布式锁，也是Redis常见的应用。
    

Redis的应用一般会结合项目去问，以一个电商项目的用户服务为例：

-   Token存储：用户登录成功之后，使用Redis存储Token
-   登录失败次数计数：使用Redis计数，登录失败超过一定次数，锁定账号
-   地址缓存：对省市区数据的缓存
-   分布式锁：分布式环境下登录、注册等操作加分布式锁
### Redis 有哪些数据结构？
![[Pasted image 20221014171149.png]]
Redis有五种基本数据结构。

**string**

字符串最基础的数据结构。字符串类型的值实际可以是字符串（简单的字符串、复杂的字符串（例如JSON、XML））、数字 （整数、浮点数），甚至是二进制（图片、音频、视频），但是值最大不能超过512MB。

字符串主要有以下几个典型使用场景：

-   缓存功能
-   计数
-   共享Session
-   限速

**hash**

哈希类型是指键值本身又是一个键值对结构。

哈希主要有以下典型应用场景：

-   缓存用户信息
-   缓存对象

**list**

列表（list）类型是用来存储多个有序的字符串。列表是一种比较灵活的数据结构，它可以充当栈和队列的角色

列表主要有以下几种使用场景：

-   消息队列
-   文章列表

**set**

集合（set）类型也是用来保存多个的字符串元素，但和列表类型不一 样的是，集合中不允许有重复元素，并且集合中的元素是无序的。

集合主要有如下使用场景：

-   标签（tag）
-   共同关注

**sorted set**

有序集合中的元素可以排序。但是它和列表使用索引下标作为排序依据不同的是，它给每个元素设置一个权重（score）作为排序的依据。

有序集合主要应用场景：

-   用户点赞统计
-   用户排序
### Redis为什么快呢？

Redis的速度⾮常的快，单机的Redis就可以⽀撑每秒十几万的并发，相对于MySQL来说，性能是MySQL的⼏⼗倍。速度快的原因主要有⼏点：

1.  **完全基于内存操作**
2.  使⽤单线程，避免了线程切换和竞态产生的消耗
3.  基于⾮阻塞的IO多路复⽤机制
4.  C语⾔实现，优化过的数据结构，基于⼏种基础的数据结构，redis做了⼤量的优化，性能极⾼
![[Pasted image 20221014171334.png]]
### 能说一下I/O多路复用吗？

引用知乎上一个高赞的回答来解释什么是I/O多路复用。假设你是一个老师，让30个学生解答一道题目，然后检查学生做的是否正确，你有下面几个选择：

-   第一种选择：按顺序逐个检查，先检查A，然后是B，之后是C、D。。。这中间如果有一个学生卡住，全班都会被耽误。这种模式就好比，你用循环挨个处理socket，根本不具有并发能力。
    
-   第二种选择：你创建30个分身，每个分身检查一个学生的答案是否正确。 这种类似于为每一个用户创建一个进程或者- 线程处理连接。
    
-   第三种选择，你站在讲台上等，谁解答完谁举手。这时C、D举手，表示他们解答问题完毕，你下去依次检查C、D的答案，然后继续回到讲台上等。此时E、A又举手，然后去处理E和A。
    

第一种就是阻塞IO模型，第三种就是I/O复用模型。

![[Pasted image 20221014171349.png]]
### Redis为什么早期选择单线程
官方FAQ表示，因为Redis是基于内存的操作，CPU成为Redis的瓶颈的情况很少见，Redis的瓶颈最有可能是内存的大小或者网络限制。

如果想要最大程度利用CPU，可以在一台机器上启动多个Redis实例。

PS：网上有这样的回答，吐槽官方的解释有些敷衍，其实就是历史原因，开发者嫌多线程麻烦，后来这个CPU的利用问题就被抛给了使用者。

同时FAQ里还提到了， Redis 4.0 之后开始变成多线程，除了主线程外，它也有后台线程在处理一些较为缓慢的操作，例如清理脏数据、无用连接的释放、大 Key 的删除等等
### Redis6.0使用多线程是怎么回事?

Redis不是说用单线程的吗？怎么6.0成了多线程的？

Redis6.0的多线程是用多线程来处理数据的**读写和协议解析**，但是Redis**执行命令**还是单线程的。
![[Pasted image 20221014171508.png]]
这样做的⽬的是因为Redis的性能瓶颈在于⽹络IO⽽⾮CPU，使⽤多线程能提升IO读写的效率，从⽽整体提⾼Redis的性能。
### Redis持久化⽅式有哪些？有什么区别？
**RDB**

RDB持久化是把当前进程数据生成**快照**保存到硬盘的过程，触发RDB持久化过程分为手动触发和自动触发。

RDB⽂件是⼀个压缩的⼆进制⽂件，通过它可以还原某个时刻数据库的状态。由于RDB⽂件是保存在硬盘上的，所以即使Redis崩溃或者退出，只要RDB⽂件存在，就可以⽤它来恢复还原数据库的状态。

手动触发分别对应save和bgsave命令:
![[Pasted image 20221014171751.png]]
-   save命令：阻塞当前Redis服务器，直到RDB过程完成为止，对于内存比较大的实例会造成长时间阻塞，线上环境不建议使用。
    
-   bgsave命令：Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。
    

以下场景会自动触发RDB持久化：

-   使用save相关配置，如“save m n”。表示m秒内数据集存在n次修改时，自动触发bgsave。
-   如果从节点执行全量复制操作，主节点自动执行bgsave生成RDB文件并发送给从节点
-   执行debug reload命令重新加载Redis时，也会自动触发save操作
-   默认情况下执行shutdown命令时，如果没有开启AOF持久化功能则自动执行bgsave。
**AOF**

AOF（append only file）持久化：以独立日志的方式记录每次写命令， 重启时再重新执行AOF文件中的命令达到恢复数据的目的。AOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的主流方式。

AOF的工作流程操作：命令写入 （append）、文件同步（sync）、文件重写（rewrite）、重启加载 （load）
![[Pasted image 20221014171809.png]]
流程如下：

1）所有的写入命令会追加到aof_buf（缓冲区）中。

2）AOF缓冲区根据对应的策略向硬盘做同步操作。

3）随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩 的目的。

4）当Redis服务器重启时，可以加载AOF文件进行数据恢复。

### RDB 和 AOF 各自有什么优缺点？

**RDB | 优点**

1.  只有一个紧凑的二进制文件 `dump.rdb`，非常适合备份、全量复制的场景。
2.  **容灾性好**，可以把RDB文件拷贝道远程机器或者文件系统张，用于容灾恢复。
3.  **恢复速度快**，RDB恢复数据的速度远远快于AOF的方式

**RDB | 缺点**

1.  **实时性低**，RDB 是间隔一段时间进行持久化，没法做到实时持久化/秒级持久化。如果在这一间隔事件发生故障，数据会丢失。
2.  **存在兼容问题**，Redis演进过程存在多个格式的RDB版本，存在老版本Redis无法兼容新版本RDB的问题。

**AOF | 优点**

1.  **实时性好**，aof 持久化可以配置 `appendfsync` 属性，有 `always`，每进行一次命令操作就记录到 aof 文件中一次。
2.  通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。

**AOF | 缺点**

1.  AOF 文件比 RDB **文件大**，且 **恢复速度慢**。
2.  **数据集大** 的时候，比 RDB **启动效率低**。

### RDB和AOF如何选择？

-   一般来说， 如果想达到足以媲美数据库的 **数据安全性**，应该 **同时使用两种持久化功能**。在这种情况下，当 Redis 重启的时候会优先载入 AOF 文件来恢复原始的数据，因为在通常情况下 AOF 文件保存的数据集要比 RDB 文件保存的数据集要完整。
-   如果 **可以接受数分钟以内的数据丢失**，那么可以 **只使用 RDB 持久化**。
-   有很多用户都只使用 AOF 持久化，但并不推荐这种方式，因为定时生成 RDB 快照（snapshot）非常便于进行数据备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快，除此之外，使用 RDB 还可以避免 AOF 程序的 bug。
-   如果只需要数据在服务器运行的时候存在，也可以不使用任何持久化方式。
### Redis的数据恢复？

当Redis发生了故障，可以从RDB或者AOF中恢复数据。

恢复的过程也很简单，把RDB或者AOF文件拷贝到Redis的数据目录下，如果使用AOF恢复，配置文件开启AOF，然后启动redis-server即可。
![[Pasted image 20221014172001.png]]

**Redis** 启动时加载数据的流程：

1.  AOF持久化开启且存在AOF文件时，优先加载AOF文件。
2.  AOF关闭或者AOF文件不存在时，加载RDB文件。
3.  加载AOF/RDB文件成功后，Redis启动成功。
4.  AOF/RDB文件存在错误时，Redis启动失败并打印错误信息。
### Redis 4.0 的混合持久化了解吗？
重启 Redis 时，我们很少使用 `RDB` 来恢复内存状态，因为会丢失大量数据。我们通常使用 AOF 日志重放，但是重放 AOF 日志性能相对 `RDB` 来说要慢很多，这样在 Redis 实例很大的情况下，启动需要花费很长的时间。

**Redis 4.0** 为了解决这个问题，带来了一个新的持久化选项——**混合持久化**。将 `rdb` 文件的内容和增量的 AOF 日志文件存在一起。这里的 AOF 日志不再是全量的日志，而是 **自持久化开始到持久化结束** 的这段时间发生的增量 AOF 日志，通常这部分 AOF 日志很小：
![[Pasted image 20221014172041.png]]
于是在 Redis 重启的时候，可以先加载 `rdb` 的内容，然后再重放增量 AOF 日志就可以完全替代之前的 AOF 全量文件重放，重启效率因此大幅得到提升。
[[redis面试题2]]
